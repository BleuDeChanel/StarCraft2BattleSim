
	L = Get possible units for us from race and ???
	R1 = List of names of the unit
	R2 = resources left after battle of unit
	
	damageCalculation(L, R1, R2) :- Head do calculation put result in R.
	
	 The result of the battle calculation is a list L where each element in L is units name and total hp left after battle


    After doing each unit and getting results calculate resource effiecieny based on units left and this units cost.

	BR  = battle result of this unit's damage calculation
	
	R is our result list which will have the unit and its total resources after battle

	resource effiecieny calculation(BR, R)

	H how many units we have left = ceiling(HP total of our units after battle/hp of one unit) 
	H*cost of one unit = total resources after battle.

	find highest resources left(R).

	ex) 
	Resource available = 400 minerals, 0 gas
	User's race = Protoss
	Enemy's unit = zergling
	Enemy unit's number = 6


	R1 = [probe, zealot]
	R2 = []


Order of calculation.

1) build a list of units available from User's race
ex) User's race = protoss;
	return ListofAllUnits = [probe, zealot, sentry, stalker, adept, darkTemplar, immortal, colossus]

2) build maximum number of each units with the given resources

ex)
% UnitsBuilt is the number of unit U built from recourses given (iterate each U in R1)
Maybe rename builtUnits into calaculateUnitCount ?

?- builtUnits(probe, 400, 0, UnitsBuilt)
UnitsBuilt = 8;
?- builtUnits(zealot, 400, 0, UnitsBuilt) 
UnitsBuilt = 4;
?- builtUnits(sentry, 400, 0, UnitsBuilt)
UnitsBuilt = 0;
?- builtUnits(stalker, 400, 0, UnitsBuilt)
UnitsBuilt = 0;
?- builtUnits(adept, 400, 0, UnitsBuilt)
UnitsBuilt = 0;
?- builtUnits(darkTemplar, 400, 0, UnitsBuilt)
UnitsBuilt = 0;
?- builtUnits(immortal, 400, 0, UnitsBuilt)
UnitsBuilt = 0;
?- builtUnits(colossus, 400, 0, UnitsBuilt)
UnitsBuilt = 0;

Then using this helper, make availableUnits return the filtered list?



availableUnit(Unit, MinAvailable, GasAvailable, Res) :- buildUnits(Unit, MinAvailable, GasAvailable, N), N>0, Res is 1.


% availableUnits(MinAvailable, GasAvailable, ListOfAllUnits, Acc, Result)
availableUnits2(MinAvailable, GasAvailable, [], L, L).
availableUnits2(MinAvailable, GasAvailable, [H|T], Acc, Result) :- availableUnit(H, MinAvailable, GasAvailable, 1), availableUnits2(MinAvailable, GasAvailable, T, [H|Acc], Result).







% availableUnits(AllUnits, Acc, Result). (AllUnits is ListofAllUnits)
// availableUnits([],[],[]).
availableUnits([],L,L).
availableUnits([H|T],Acc,[H|RT]) :- N>0, builtUnits(H, MinAvailable, GasAvailable, N), availableUnits(T,[Acc|[H]],RT). 
// availableUnits([H|T],Acc,[D|RT]) :- dif(H,D), N>0, builtUnits(H, MinAvailable, GasAvailable, N), availableUnits(T,Acc,RT).

?- availableUnits([probe,zealot,sentry,stalker,adept,darkTemplar,immortal,colossus], [], R). (MinAvailable and GasAvailable inputs are availabe on the upper function?) (400, 0)

R = [probe, zealot];


So if we integrate them together...

% filterUserUnit(Race, MinAvailable, GasAvailable, Result)
filterUserUnit(Race, MinAvailable, GasAvailable, Result) :- inspectRace(Race,ListofAllUnits), availableUnits(ListofAllUnits, [], Result).



UPDATE - eliminating singleton var. On Prolog file

% availableUnits(MinAvailable, GasAvailable, AllUnits, Acc, Result).
% (AllUnits is ListofAllUnits)

availableUnits(_, _,[],L,L).
availableUnits(MinAvailable, GasAvailable, [H|T],Acc,[H|RT]) :- buildUnits(H, MinAvailable, GasAvailable, N), N>0, availableUnits(MinAvailable, GasAvailable,T,[H|Acc],RT).

availableUnits(MinAvailable, GasAvailable, [H|T],Acc,[D|RT]) :- dif(H,D), buildUnits(H, MinAvailable, GasAvailable, N), N>0, availableUnits(MinAvailable, GasAvailable,T,Acc,RT).

% ?- availableUnits(400,0,[probe,zealot,sentry,stalker,adept,darkTemplar,immortal,colossus], [], R). (MinAvailable and GasAvailable inputs are availabe on the upper function?) (400, 0)
% R = [probe, zealot];

filterUserUnit(Race, MinAvailable, GasAvailable, Result) :- inspectRace(Race,ListofAllUnits), availableUnits(MinAvailable, GasAvailable, ListofAllUnits, [], Result).



FUCKING PROLOG CAN'T DEBUG - start from scratch...

availableUnits(U, L) :- findall(dif(X,0), buildUnits(U, MinAvailable, GasAvailalbe, X), L).

someFunction





3) Do damageCalculation with the available units vs enemy's unit and return how many units User have left. (Add Range calculation later if we have time)

4) With the number of survived units of User, calculate the difference between MinAvailable/GasAvailabe and cost of the survived units. Then the unit with the lowest (min) number of this result (the difference) is most cost efficient, as it represents the resource User spent for the lost units. (We may need some sort of conversion between the value of Mineral and Gas here)






5) Return the most cost efficient unit vs the input enemy's unit