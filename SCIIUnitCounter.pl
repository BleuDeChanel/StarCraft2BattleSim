prop(probe, mineral, 50).
prop(probe, gas, 0).
prop(probe, armour, 0).
prop(probe, hp, 20).
prop(probe, shield, 20).
prop(probe, race, protoss).
prop(probe, attributeModifier, [light,mechanical]).
prop(probe, groundAttack, 5).
prop(probe, bonusAttack, 0).
prop(probe, bonusType, []).
prop(probe, coolDown, 1.07).
prop(probe, range, 0).
prop(probe, speed, 3.94).

prop(zealot, mineral, 100).
prop(zealot, gas, 0).
prop(zealot, armour, 1).
prop(zealot, hp, 100).
prop(zealot, shield, 50).
prop(zealot, race, protoss).
prop(zealot, attributeModifier, [light,biological]).
prop(zealot, groundAttack, 16).
prop(zealot, bonusAttack, 0).
prop(zealot, bonusType, []).
prop(zealot, coolDown, 0.86).
prop(zealot, range, 0).
prop(zealot, speed, 3.15).

prop(sentry, mineral, 50).
prop(sentry, gas, 100).
prop(sentry, armour, 1).
prop(sentry, hp, 40).
prop(sentry, shield, 40).
prop(sentry, race, protoss).
prop(sentry, attributeModifier, [light,mechanical,psionic]).
prop(sentry, groundAttack, 6).
prop(sentry, bonusAttack, 0).
prop(sentry, bonusType, []).
prop(sentry, coolDown, 0.71).
prop(sentry, range, 5).
prop(sentry, speed, 3.15).

prop(stalker, mineral, 125).
prop(stalker, gas, 50).
prop(stalker, armour, 1).
prop(stalker, hp, 80).
prop(stalker, shield, 80).
prop(stalker, race, protoss).
prop(stalker, attributeModifier, [armoured,mechanical]).
prop(stalker, groundAttack, 10).
prop(stalker, bonusAttack, 4).
prop(stalker, bonusType, [armoured]).
prop(stalker, coolDown, 1.03).
prop(stalker, range, 6).
prop(stalker, speed, 4.13).

prop(adept, mineral, 100).
prop(adept, gas, 25).
prop(adept, armour, 1).
prop(adept, hp, 70).
prop(adept, shield, 70).
prop(adept, race, protoss).
prop(adept, attributeModifier, [light,biological]).
prop(adept, groundAttack, 10).
prop(adept, bonusAttack, 12).
prop(adept, bonusType, [light]).
prop(adept, coolDown, 1.61).
prop(adept, range, 4).
prop(adept, speed, 3.5).

prop(darkTemplar, mineral, 125).
prop(darkTemplar, gas, 125).
prop(darkTemplar, armour, 1).
prop(darkTemplar, hp, 40).
prop(darkTemplar, shield, 80).
prop(darkTemplar, race, protoss).
prop(darkTemplar, attributeModifier, [light,biological,psionic]).
prop(darkTemplar, groundAttack, 10).
prop(darkTemplar, bonusAttack, 12).
prop(darkTemplar, bonusType, [light]).
prop(darkTemplar, coolDown, 1.61).
prop(darkTemplar, range, 4).
prop(darkTemplar, speed, 3.5).

prop(immortal, mineral, 250).
prop(immortal, gas, 100).
prop(immortal, armour, 1).
prop(immortal, hp, 200).
prop(immortal, shield, 100).
prop(immortal, race, protoss).
prop(immortal, attributeModifier, [armoured,mechanical]).
prop(immortal, groundAttack, 20).
prop(immortal, bonusAttack, 30).
prop(immortal, bonusType, [armoured]).
prop(immortal, coolDown, 1.04).
prop(immortal, range, 6).
prop(immortal, speed, 3.15).

prop(colossus, mineral, 300).
prop(colossus, gas, 200).
prop(colossus, armour, 1).
prop(colossus, hp, 200).
prop(colossus, shield, 150).
prop(colossus, race, protoss).
prop(colossus, attributeModifier, [armoured,mechanical,massive]).
prop(colossus, groundAttack, 12).
prop(colossus, bonusAttack, 0).
prop(colossus, bonusType, []).
prop(colossus, coolDown, 1.18).
prop(colossus, range, 6).
prop(colossus, speed, 3.15).

prop(scv, mineral, 50).
prop(scv, gas, 0).
prop(scv, armour, 0).
prop(scv, hp, 45).
prop(scv, shield, 0).
prop(scv, race, terran).
prop(scv, attributeModifier, [light,biological,mechanical]).
prop(scv, groundAttack, 5).
prop(scv, bonusAttack, 0).
prop(scv, bonusType, []).
prop(scv, coolDown, 1.07).
prop(scv, range, 0).
prop(scv, speed, 3.94).

prop(marine, mineral, 50).
prop(marine, gas, 0).
prop(marine, armour, 0).
prop(marine, hp, 45).
prop(marine, shield, 0).
prop(marine, race, terran).
prop(marine, attributeModifier, [light,biological]).
prop(marine, groundAttack, 6).
prop(marine, bonusAttack, 0).
prop(marine, bonusType, []).
prop(marine, coolDown, 0.61).
prop(marine, range, 5).
prop(marine, speed, 3.15).

prop(marauder, mineral, 100).
prop(marauder, gas, 25).
prop(marauder, armour, 1).
prop(marauder, hp, 125).
prop(marauder, shield, 0).
prop(marauder, race, terran).
prop(marauder, attributeModifier, [armoured, biological]).
prop(marauder, groundAttack, 10).
prop(marauder, bonusAttack, 5).
prop(marauder, bonusType, [armoured]).
prop(marauder, coolDown, 1.07).
prop(marauder, range, 6).
prop(marauder, speed, 3.15).

prop(reaper, mineral, 50).
prop(reaper, gas, 50).
prop(reaper, armour, 0).
prop(reaper, hp, 60).
prop(reaper, shield, 0).
prop(reaper, race, terran).
prop(reaper, attributeModifier, [light,biological]).
prop(reaper, groundAttack, 8).
prop(reaper, bonusAttack, 0).
prop(reaper, bonusType, []).
prop(reaper, coolDown, 0.79).
prop(reaper, range, 5).
prop(reaper, speed, 5.25).

prop(ghost, mineral, 200).
prop(ghost, gas, 100).
prop(ghost, armour, 0).
prop(ghost, hp, 100).
prop(ghost, shield, 0).
prop(ghost, race, terran).
prop(ghost, attributeModifier, [biological, psionic]).
prop(ghost, groundAttack, 10).
prop(ghost, bonusAttack, 10).
prop(ghost, bonusType, [light]).
prop(ghost, coolDown, 1.07).
prop(ghost, range, 6).
prop(ghost, speed, 3.94).

prop(hellbat, mineral, 100).
prop(hellbat, gas, 0).
prop(hellbat, armour, 0).
prop(hellbat, hp, 135).
prop(hellbat, shield, 0).
prop(hellbat, race, terran).
prop(hellbat, attributeModifier, [light, biological, mechanical]).
prop(hellbat, groundAttack, 18).
prop(hellbat, bonusAttack, 12).
prop(hellbat, bonusType, [light]).
prop(hellbat, coolDown, 1.43).
prop(hellbat, range, 2).
prop(hellbat, speed, 3.15).

prop(cyclone, mineral, 150).
prop(cyclone, gas, 100).
prop(cyclone, armour, 1).
prop(cyclone, hp, 180).
prop(cyclone, shield, 0).
prop(cyclone, race, terran).
prop(cyclone, attributeModifier, [armoured, mechanical]).
prop(cyclone, groundAttack, 3).
prop(cyclone, bonusAttack, 2).
prop(cyclone, bonusType, [armoured]).
prop(cyclone, coolDown, 0.1).
prop(cyclone, range, 4).
prop(cyclone, speed, 4.13).

prop(drone, mineral, 50).
prop(drone, gas, 0).
prop(drone, armour, 0).
prop(drone, hp, 40).
prop(drone, shield, 0).
prop(drone, race, zerg).
prop(drone, attributeModifier, [light,biological]).
prop(drone, groundAttack, 5).
prop(drone, bonusAttack, 0).
prop(drone, bonusType, []).
prop(drone, coolDown, 1.07).
prop(drone, range, 0).
prop(drone, speed, 3.94).

prop(queen, mineral, 150).
prop(queen, gas, 0).
prop(queen, armour, 1).
prop(queen, hp, 175).
prop(queen, shield, 0).
prop(queen, race, zerg).
prop(queen, attributeModifier, [biological,psionic]).
prop(queen, groundAttack, 8).
prop(queen, bonusAttack, 0).
prop(queen, bonusType, []).
prop(queen, coolDown, 0.71).
prop(queen, range, 5).
prop(queen, speed, 1.31).

prop(zergling, mineral, 25).
prop(zergling, gas, 0).
prop(zergling, armour, 0).
prop(zergling, hp, 35).
prop(zergling, shield, 0).
prop(zergling, race, zerg).
prop(zergling, attributeModifier, [light,biological]).
prop(zergling, groundAttack, 5).
prop(zergling, bonusAttack, 0).
prop(zergling, bonusType, []).
prop(zergling, coolDown, 0.497).
prop(zergling, range, 0).
prop(zergling, speed, 4.13).

prop(roach, mineral, 75).
prop(roach, gas, 25).
prop(roach, armour, 1).
prop(roach, hp, 145).
prop(roach, shield, 0).
prop(roach, race, zerg).
prop(roach, attributeModifier, [biological]).
prop(roach, groundAttack, 16).
prop(roach, bonusAttack, 0).
prop(roach, bonusType, []).
prop(roach, coolDown, 1.14).
prop(roach, range, 6).
prop(roach, speed, 3.85).

prop(ravager, mineral, 25).
prop(ravager, gas, 75).
prop(ravager, armour, 1).
prop(ravager, hp, 120).
prop(ravager, shield, 0).
prop(ravager, race, zerg).
prop(ravager, attributeModifier, [armoured,biological]).
prop(ravager, groundAttack, 16).
prop(ravager, bonusAttack, 0).
prop(ravager, bonusType, []).
prop(ravager, coolDown, 1.43).
prop(ravager, range, 4).
prop(ravager, speed, 3.15).

prop(hydralisk, mineral, 100).
prop(hydralisk, gas, 50).
prop(hydralisk, armour, 0).
prop(hydralisk, hp, 90).
prop(hydralisk, shield, 0).
prop(hydralisk, race, zerg).
prop(hydralisk, attributeModifier, [light,biological]).
prop(hydralisk, groundAttack, 12).
prop(hydralisk, bonusAttack, 0).
prop(hydralisk, bonusType, []).
prop(hydralisk, coolDown, 0.54).
prop(hydralisk, range, 5).
prop(hydralisk, speed, 3.15).

prop(ultralisk, mineral, 300).
prop(ultralisk, gas, 200).
prop(ultralisk, armour, 2).
prop(ultralisk, hp, 500).
prop(ultralisk, shield, 0).
prop(ultralisk, race, zerg).
prop(ultralisk, attributeModifier, [armoured,biological,massive]).
prop(ultralisk, groundAttack, 35).
prop(ultralisk, bonusAttack, 0).
prop(ultralisk, bonusType, []).
prop(ultralisk, coolDown, 0.61).
prop(ultralisk, range, 1).
prop(ultralisk, speed, 4.13).


% Knowledgebase using Triple
%
% Properties we are keeping
% - Mineral: How much mineral needed to make one unit
% - Gas: How much gas neede to make one unit
% - Armor: Default armor of the unit
% - Hp: Default hp of the unit
% - Shield: Default Plasma Shielf of the unit (Only Protoss unit)
% - AttributeModifier: Attribute modifiers of the unit
% - Ground Attack: Default ground attack damage of the unit
% - BonusAttack:how much bonus attack does this unit has to BonusType
% - BonusType:to which type does this unit has a bonus attack
% - Race: Race of the unit
% - Range: Range of the unit's attack
% - Speed: Movement speed of the unit

% damage calculation
% # of unit * ( (basic attack + bonus) / cooldown ) = Total dps

% Unit is the enemies unit you wish to fight
% NumberOfUnits is the number of the enemy's unit
% MinAvailable is how minerals you can spend on your army
% GasAvailable is much gas you can spend on your army
% Race is your Race, it will restrict what units you can build
% R is the result, a list of units with their resource effiecieny


%% TODO:
%% Basic validation of inputs
%% Make sure Unit is valid.
%% Make sure race is valid.
%% Make sure Minerals are given
%% Make sure NumberOfUnits > 0.


%% If Armour makes the attack of single unit go under 0.5. Make the BasicAttack do 0.5 damage. It is the minimum damage


%% Use Battle Result to get resource effiecieny of each battle which will be R.
%% Add enemy casualties to result?

%% Print out more stats from battles as they happen???
%% Import KB from other files

main(Unit, NumberOfUnits, MinAvailable, GasAvailable, Race, BattleResult) :-

	NumberOfUnits > 0,

	MinAvailable > 49,

	filterUserUnitInOrder(Race, MinAvailable, GasAvailable, ListOfPossibleUnits),
	battleSimulation(Unit, NumberOfUnits, ListOfPossibleUnits, MinAvailable, GasAvailable, BattleResult).



%% R is a race (Protoss, Zerg, Terran) of the User
%% L is a list of units this race can make that are in our KB

inspectRace(R, L) :-
	findall(X0, prop(X0, race, R), L).

%% intersects(L1, L2) is true if one of L1's elements is in L2.
intersects([H|_],List) :-
    member(H,List),
    !.
intersects([_|T],List) :-
    intersects(T,List).

%% MaxBuild is true if R is GA / GPU.
%% If GPU is 0 give -1.
maxBuild(_,0,-1).
maxBuild(GA,GPU,R) :-
	dif(GPU, 0),
	R is floor(GA / GPU).

%% SpecialMin is true when R is min of X and Y. Except -1 is max.
specialMin(-1, Y, Y).
specialMin(X, -1, X).
specialMin(X, Y, R) :-
	dif(X, -1),
	dif(Y, -1),
	R is min(X,Y).


%% U is unit to build.
%% MinAvailable is the minerals available
%% GasAvailable is the gas available
%% UnitsBuilt is the number of unit U built from recourses given
buildUnits(U, MinAvailable, GasAvailable, UnitsBuilt) :-
	prop(U, gas, GasPerUnit),
	prop(U, mineral, MineralsPerUnit),
	maxBuild(GasAvailable, GasPerUnit, GasMax),
	maxBuild(MinAvailable, MineralsPerUnit, MineralMax),
	specialMin(GasMax, MineralMax, UnitsBuilt).


%% Grants free hits for opponent with higher range based on slower units movement speed to get into range.
%% EUnit hits first
rangeChecker(EUnit, Unit, 0, NextHit) :-
	prop(EUnit, range, ER),
	prop(Unit, range, R),
	ER > R,
	Distance is ER - R,
	prop(Unit, speed, Speed),
	Tick is 0.01,
	MovePerTick is Speed * Tick,
	NextHit is Distance / MovePerTick,
	print_message(informational, rangeMessage(EUnit, Unit, ER, R, NextHit)).

%% Unit hits first
rangeChecker(EUnit, Unit, ENextHit, 0) :-
	prop(EUnit, range, ER),
	prop(Unit, range, R),
	R > ER,
	Distance is R - ER,
	prop(EUnit, speed, Speed),
	Tick is 0.01,
	MovePerTick is Speed * Tick,
	ENextHit is Distance / MovePerTick,
	print_message(informational, rangeMessage(Unit, EUnit, R, ER, ENextHit)).

%% Same range
rangeChecker(EUnit, Unit, 0, 0) :-
	prop(EUnit, range, ER),
	prop(Unit, range, R),
	R = ER,
	print_message(informational, rangeMessage(Unit, EUnit, R, ER, 0)).


%% battleSimulation(Unit, NumberOfUnits, L, MinAvailable, GasAvailable, R). is true when:
%% Unit is the enemies unit
%% EUnitLeft is the number of enemy units
%% L is a list of units this will simulate battle for
%% MinAvailable is how many minerals you have available
%% GasAvailable is how much gas you have available
%% R is a list of elements. Each element has (Unit, UnitsLeft of the player, Enemy Units Left)
battleSimulation(_, _, [], _, _, []).
battleSimulation(EUnit, EUnitLeft, [Unit|T], MinAvailable, GasAvailable, [R1 | R]) :-
	print_message(banner, enteringBattleMessage(EUnitLeft, EUnit, Unit)),
	buildUnits(Unit, MinAvailable, GasAvailable, UnitLeft),
	print_message(informational, buildMessage(Unit, UnitLeft, MinAvailable, GasAvailable)),
	rangeChecker(EUnit, Unit, ENextHit, NextHit),
	prop(EUnit, hp, EHP),
	prop(Unit, hp, HP),
	prop(EUnit, shield, EShield),
	prop(Unit, shield, Shield),
	OriginalEUnitLeft is EUnitLeft,
	print_message(banner, battleBanner()),
	tick(EUnit, Unit, EUnitLeft, UnitLeft, ENextHit, NextHit, (EHP, EShield), (HP, Shield), R1),
	battleSimulation(EUnit, OriginalEUnitLeft, T, MinAvailable, GasAvailable, R).


prolog:message(enteringBattleMessage(EUnitLeft, EUnit, Unit)) -->
        [ '\n ====================SIMULATION START====================  \n ~w is entering battle against the enemies ~D ~ws'-[Unit, EUnitLeft, EUnit] ].

prolog:message(buildMessage(Unit, UnitLeft, MinAvailable, GasAvailable)) -->
        [ 'BUILD UNITS: Built ~D ~ws from ~D Minerals ~D Gas'-[UnitLeft, Unit, MinAvailable, GasAvailable] ].

prolog:message(rangeMessage(Unit1, Unit2, Unit1Range, Unit2Range, Unit2AttackTime)) -->
        [ 'RANGE CHECK: ~w has ~D Range. ~w has ~D Range. \n It will take ~5fms for ~w to get in range.'-[Unit1, Unit1Range, Unit2, Unit2Range, Unit2AttackTime, Unit2] ].

prolog:message(battleBanner()) -->
        [ '====================BATTLE START===================='-[] ].

prolog:message(attackMessage(Unit1, NumUnit1, SingleAttack, Unit2, Damage)) -->
        [ '~D ~ws attack ~w for ~D each. ~D Total Damage'-[NumUnit1, Unit1, Unit2, SingleAttack, Damage] ].

prolog:message(attackBanner()) -->
        [ '==========ATTACK=========='-[] ].

prolog:message(defendMessage(Defender, DefenderUnitsLeft, (TankHP,TankShield), Damage)) -->
        [ '~w takes ~D damage. ~D ~ws left. Focused unit has ~D HP ~D Shield left.'-[Defender, Damage, DefenderUnitsLeft, Defender, TankHP, TankShield] ].

prolog:message(defendBanner()) -->
        [ '==========DEFEND=========='-[] ].

prolog:message(defenderDiedMessage(Defender, DefenderUnitsLeft, Damage, OverDamage)) -->
        [ '~w took ~D damage and died. ~D ~ws left. Leftover ~D damage passed on to next target, if it exists.'-[Defender, Damage,  DefenderUnitsLeft, Defender, OverDamage] ].

prolog:message(nextAttackMessage(EUnit,Unit,NewENextHit, NewNextHit)) -->
        [ '~w can attack in ~5fms. ~w can attack in ~5fms.'-[Unit, NewNextHit, EUnit, NewENextHit] ].

prolog:message(nextAttackBanner()) -->
        [ '==========JUMP TO NEXT ATTACK=========='-[] ].

prolog:message(battleEnd(DeadUnit, AliveUnit, AliveLeft)) -->
        [ 'All ~ws are dead. There are ~D ~ws left.'-[DeadUnit, AliveLeft, AliveUnit] ].

prolog:message(battleEndBanner()) -->
        [ '==========BATTLE END=========='-[] ].

%% getBonusAttack will take in a defender and Attacker and return the Attacker's BonusAttack against the Defender in BonusAttack.
%% Note: Currently it does not support a unit having different bonusAttacks for different Defenders
%% Gets Attacker's BonusType array and Defender's AttributeModifier array and see's if a value matches.
%% If a value matches set BonusAttack. If not return 0.

%% Case: Attacker's bonusAttack is 0 for all. Return 0.
getBonusAttack(Attacker, _, 0) :-
	prop(Attacker, bonusAttack, BonusAttack),
	BonusAttack = 0.

%% Case: we have a match in BonusTypes and AttributeModifiers so the bonusAttack applies
getBonusAttack(Attacker, Defender, BonusAttack) :-
	prop(Attacker, bonusAttack, BonusAttack),
	BonusAttack > 0,
	prop(Attacker, bonusType, BonusTypes),
	prop(Defender, attributeModifier, AttributeModifiers),
	intersects(BonusTypes, AttributeModifiers).

%% No match in BonusTypes and AttributeModifiers so the bonusAttack is 0
getBonusAttack(Attacker, Defender, 0) :-
	prop(Attacker, bonusAttack, BonusAttack),
	BonusAttack > 0,
	prop(Attacker, bonusType, BonusTypes),
	prop(Defender, attributeModifier, AttributeModifiers),
	\+ intersects(BonusTypes, AttributeModifiers).



%% Gets Damage for this attack done by Attacker on Defender
%% Damage = UnitLeft * ( ( BasicAttack + BonusAttack - EArmour) ).
%% Add shield armour value.
%% Tests:
%% attack(zealot, 500, zealot, D). Expect D = 7500
attack(Attacker, AttackerUnitleft, Defender, Damage) :-
	prop(Attacker, groundAttack, BasicAttack),
	getBonusAttack(Attacker, Defender, BonusAttack),
	prop(Defender, armour, DefenderArmour),
	SingleAttack is BasicAttack + BonusAttack - DefenderArmour,
	Damage is AttackerUnitleft * SingleAttack,
	print_message(informational, attackMessage(Attacker, AttackerUnitleft, SingleAttack, Defender, Damage)).

%% NOTE: Shield will use same Armour as its unit's Armour.
%% It should have it's own armour value.

%%	Looking into Attack
%%		1. Must keep track of UnitsLeft.
%%		2. Keep track of one DamagedUnit per side. Damaged unit is (HPLeft, ShieldLeft)
%%		3. An attack is
%%			Damage = UnitLeft * ( ( BasicAttack + BonusAttack - EArmour) ).
%%			TempHP = EDamagedUnit's HP
%%			EDamagedUnit's HP = EDamagedUnit's HP - Damage. If 0, dead. EUnitLeft - 1. EDamagedUnit HP set to full.
%%			Damage = Damage - TempHP.
%%			Repeat till Damage is 0.
%% Base case
%% Defender lives. Set the New values.
%% Case 1: Shield doesn't break
%% Tests:
%% defend(10, zealot, (100,50),1,(NewHP, NewShield), NewLeft).
defend(Damage, Defender, (DefenderDamagedUnitHP, DefenderDamagedUnitShield), DefenderUnitLeft, (DefenderDamagedUnitHP, NewDefenderDamagedUnitShield), DefenderUnitLeft) :-
	dif(DefenderUnitLeft,0),
	dif(Damage,0),
	NewDefenderDamagedUnitShield is DefenderDamagedUnitShield - Damage,
	NewDefenderDamagedUnitShield >= 0,
	print_message(informational, defendMessage(Defender, DefenderUnitLeft, (DefenderDamagedUnitHP,NewDefenderDamagedUnitShield), Damage)).


%% Case 2: Shield does break, Unit lives
%% Tests:
%% defend(50, zealot, (100,50),1,(NewHP, NewShield), NewLeft).
%% defend(75, zealot, (100,0),1,(NewHP, NewShield), NewLeft).
%% defend(75, zealot, (100,5),1,(NewHP, NewShield), NewLeft).

defend(Damage, Defender, (DefenderDamagedUnitHP, DefenderDamagedUnitShield), DefenderUnitLeft, (NewDefenderDamagedUnitHP, 0), DefenderUnitLeft) :-
	dif(DefenderUnitLeft,0),
	dif(Damage,0),
	NewDefenderDamagedUnitShield is DefenderDamagedUnitShield - Damage,
	NewDefenderDamagedUnitShield < 0,
	NewDamage is Damage - DefenderDamagedUnitShield,
	NewDefenderDamagedUnitHP is DefenderDamagedUnitHP - NewDamage,
	NewDefenderDamagedUnitHP > 0,
	print_message(informational, defendMessage(Defender, DefenderUnitLeft, (NewDefenderDamagedUnitHP,0), Damage)).

%% Case 3: Defender Dies
%% Reduce Total Damage left
%% Check if shield breaks
%% Check if HP hits 0
%% Subtract total damage
%% Setup new frontline unit
%% Unit count down by one
%% Tests:
%% defend(1000, zealot, (100,50),100,(NewHP, NewShield), NewLeft).	Expect: NewHP = 50  NewShield = 0  NewLeft = 94
%% defend(250, zealot, (100,50),2,(NewHP, NewShield), NewLeft).		Expect: NewHP = 50  NewShield = 0  NewLeft = 1
%% defend(300, zealot, (100,50),2,(NewHP, NewShield), NewLeft).		Expect: NewHP = 100 NewShield = 50 NewLeft = 0
defend(Damage, Defender, (DefenderDamagedUnitHP, DefenderDamagedUnitShield), DefenderUnitLeft, (NewDefenderDamagedUnitHP, NewDefenderDamagedUnitShield), NewDefenderUnitLeft) :-
	dif(DefenderUnitLeft,0),
	dif(Damage,0),
	TempShield is DefenderDamagedUnitShield - Damage,
	TempShield < 0,
	NewDamage is Damage - DefenderDamagedUnitShield,
	TempHP is DefenderDamagedUnitHP - NewDamage,
	TempHP =< 0,
	NewNewDamage is NewDamage - DefenderDamagedUnitHP,
	prop(Defender, shield, FreshShield),
	prop(Defender, hp, FreshHP),
	TempUnitLeft is DefenderUnitLeft - 1,
	DamageTaken is Damage - NewNewDamage,
	print_message(informational, defenderDiedMessage(Defender, TempUnitLeft, DamageTaken, NewNewDamage)),
	defend(NewNewDamage, Defender, (FreshHP, FreshShield), TempUnitLeft, (NewDefenderDamagedUnitHP, NewDefenderDamagedUnitShield), NewDefenderUnitLeft).


%% After unit died in defence, and 0 units left Done.
defend(_, _, (_, _), 0, (0, 0), 0).

%% 0 damage left after unit died, defence is over
defend(0, _, (DefenderDamagedUnitHP, DefenderDamagedUnitShield), TempUnitLeft, (DefenderDamagedUnitHP, DefenderDamagedUnitShield), TempUnitLeft) :-
	dif(TempUnitLeft,0).


%% Jumps to next attack

%% No one can hit. Jump to next attack. Cases: Enemey is next hit, You're next hit, you both are next hit(same ENextHit and NextHit)
%% Enemy is next hit
goToNextAttack(ENextHit, NextHit, 0, NewNextHit) :-
	dif(ENextHit,NextHit),
	ENextHit < NextHit,
	NewNextHit is NextHit - ENextHit.

%% You're next hit
goToNextAttack(ENextHit, NextHit, NewENextHit, 0) :-
	dif(ENextHit,NextHit),
	NextHit < ENextHit,
	NewENextHit is ENextHit - NextHit.
%% Both are next hit
goToNextAttack(NextHit, NextHit, 0, 0).

%% Looking at Tick
%%	One of ENextHit and NextHit is 0.
%%
%%	1.
%%		Need to keep track of NextHit.
%%		Everytime NextHit hits 0:
%%			1. Attack.
%%			2. Set NextHit to CD.
%% tick(EUnit, Unit, EUnitLeft, UnitLeft, ENextHit, NextHit, DamagedUnit, EDamagedUnit, R)
%% Eunit - Enemy's Unit
%% Unit - Your Unit
%% EUnitLeft - Enemy's units left (Battle is over when at 0)
%% UnitLeft - Your units left (Battle is over when at 0)
%% ENextHit - Ticks till enemy can attack (attacks at 0)
%% NextHit - Ticks till you can attack (attacks at 0)
%% EDamagedUnit - Enemy's frontline unit, gets hit first and can have non full hp/shield
%% DamagedUnit - your frontline unit, gets hit first and can have non full hp/shield
%% R is result of battle, (Unit, UnitLeft, EUnitLeft)

%% Tests:
%% tick(zealot,zealot,70,60,0,0,(100,50),(100,50),R).



%% No Enemies left!!! Record result and exit tick.
tick(EUnit, Unit, EUnitLeft, UnitLeft, _, _, _, _, (Unit,UnitLeft,0)) :-
	EUnitLeft =< 0,
	UnitLeft > 0,
	print_message(banner, battleEndBanner()),
	print_message(informational, battleEnd(EUnit, Unit, UnitLeft)).

%% No Units left :( Record result and exit tick.
tick(EUnit, Unit, EUnitLeft, UnitLeft, _, _, _, _, (Unit,0,EUnitLeft)) :-
	UnitLeft =< 0,
	print_message(banner, battleEndBanner()),
	print_message(informational, battleEnd(Unit, EUnit, EUnitLeft)).

%% Unit can hit
tick(EUnit, Unit, EUnitLeft, UnitLeft, ENextHit, 0, EDamagedUnit, DamagedUnit, R) :-
	EUnitLeft > 0,
	UnitLeft > 0,
	ENextHit > 0,
	print_message(banner, attackBanner()),
	attack(Unit, UnitLeft, EUnit, Damage),
	print_message(banner, defendBanner()),
	defend(Damage, EUnit, EDamagedUnit, EUnitLeft, NewEDamageUnit, NewEUnitLeft),
	prop(Unit, coolDown, CD),
	CDms is CD / 0.01,
	goToNextAttack(ENextHit, CDms, NewENextHit, NewNextHit),
	print_message(banner, nextAttackBanner()),
	print_message(informational, nextAttackMessage(EUnit,Unit,NewENextHit, NewNextHit)),
	tick(EUnit, Unit, NewEUnitLeft, UnitLeft, NewENextHit, NewNextHit, NewEDamageUnit, DamagedUnit, R).


%% Enemy unit can hit
tick(EUnit, Unit, EUnitLeft, UnitLeft, 0, NextHit, EDamagedUnit, DamagedUnit, R) :-
	EUnitLeft > 0,
	UnitLeft > 0,
	NextHit > 0,
	print_message(banner, attackBanner()),
	attack(EUnit, EUnitLeft, Unit, Damage),
	print_message(banner, defendBanner()),
	defend(Damage, Unit, DamagedUnit, UnitLeft, NewDamageUnit, NewUnitLeft),
	prop(EUnit, coolDown, ECD),
	ECDms is ECD / 0.01,
	goToNextAttack(ECDms, NextHit, NewENextHit, NewNextHit),
	print_message(banner, nextAttackBanner()),
	print_message(informational, nextAttackMessage(EUnit,Unit,NewENextHit, NewNextHit)),
	tick(EUnit, Unit, EUnitLeft, NewUnitLeft, NewENextHit, NewNextHit, EDamagedUnit, NewDamageUnit, R).

%% Both units can hit
%% Both attack with full force.
%% Then defend.
tick(EUnit, Unit, EUnitLeft, UnitLeft, 0, 0, EDamagedUnit, DamagedUnit, R) :-
	EUnitLeft > 0,
	UnitLeft > 0,
	print_message(banner, attackBanner()),
	attack(EUnit, EUnitLeft, Unit, EDamage),
	print_message(banner, attackBanner()),
	attack(Unit, UnitLeft, EUnit, Damage),
	print_message(banner, defendBanner()),
	defend(EDamage, Unit, DamagedUnit, UnitLeft, NewDamageUnit, NewUnitLeft),
	print_message(banner, defendBanner()),
	defend(Damage, EUnit, EDamagedUnit, EUnitLeft, NewEDamageUnit, NewEUnitLeft),
	prop(EUnit, coolDown, ECD),
	prop(Unit, coolDown, CD),
	ECDms is ECD / 0.01,
	CDms is CD / 0.01,
	goToNextAttack(ECDms,CDms,NewENextHit,NewNextHit),
	print_message(banner, nextAttackBanner()),
	print_message(informational, nextAttackMessage(EUnit,Unit,NewENextHit, NewNextHit)),
	tick(EUnit, Unit, NewEUnitLeft, NewUnitLeft, NewENextHit, NewNextHit, NewEDamageUnit, NewDamageUnit, R).


% damage calculation
% # of unit * ( (basic attack + bonus) - Earmour / cooldown ) = Total dps


%% counter (
%%	Get info about enemies unit
%%	Relevant info: Mineral, Gas, HP, Shields, Armour, Groundattack, BonusAttack, BonusType(s),Cooldown, Range

%%	L = Get possible units for us from race and ???
%%	R1 = List of names of the unit
%%	R2 = resources left after battle of unit

%%	damageCalculation(L, R1, R2) :-
%%		Head do calculation put result in R.


%%		BR  = battle result of this units damage calculation
%%		R is our result list which will have the unit and its total resources after battle
%%		resource effiecieny calculation(BR, R)
%%		H how many units we have left = ceiling(HP total of our units after battle/hp of one unit)
%%		H*cost of one unit = total resources after battle.

%%		damageCalculation(T,R)


%%	find highest resources left(R).

%% )

%% Before battle calculation we have list L of units we can build
%% Foreach unit in L
%% Build max number of units
%% Do damageCalculation against enemies units (lots of smaller parts/functions)
%% Record results

%% The result of the battle calculation is a list L where each element in L is units name and total hp left after battle


%% After doing each unit and getting results calculate resource effiecieny based on units left and this units cost.

%% Taking into account Range:
%% They get extra number of attacks based on how much higher the unit's range is compared to it's opponents.
%% # of units*attack = bonus damage from range.
%% At beginning of fight subtract bonus damage from range from enemy with lowers range total hp pool.

%% (Basic attack + bonus atk - armour)/CD * number of units is DPS.


% Jin Min trying to wrap around his head.

% Res is 1(true) if the N is greater than 0, meaning User can make the
% Unit.
availableUnit(Unit, MinAvailable, GasAvailable, Res) :- buildUnits(Unit, MinAvailable, GasAvailable, N), N>0, Res is 1.

% Builds a list of units that are available to make from the input list
%% Example availableUnits(500,0,[zealot,immortal,probe,colossus,stalker],[],R). gives R = [probe, zealot]
availableUnits(_, _, [], L, L).
availableUnits(MinAvailable, GasAvailable, [H|T], Acc, Result) :- availableUnit(H, MinAvailable, GasAvailable, 1) -> availableUnits(MinAvailable, GasAvailable, T, [H|Acc], Result); availableUnits(MinAvailable,GasAvailable,T,Acc,Result).

% Filters a list of units in reverse order according to the race and
% resources available.
filterUserUnit(Race, MinAvailable, GasAvailable, Result) :- inspectRace(Race,ListofAllUnits), availableUnits(MinAvailable, GasAvailable, ListofAllUnits, [], Result).

% Reverse the order back.
filterUserUnitInOrder(Race, MinAvailable, GasAvailable, OrderedResult) :-
	filterUserUnit(Race, MinAvailable, GasAvailable, Result),
	reverse(Result, OrderedResult).


% No longer use the TotalHPleft
%
% Calculate the mineral spent; lower the number, more efficient the
% unit is.
mineralSpent(Unit,UnitsLeft, MineralSpent) :-
	prop(Unit,mineral, MinCost),
	MineralSpent is UnitsLeft*MinCost.


% Calculate the gas spent; lower the number, more efficient the
% unit is.
gasSpent(Unit,UnitsLeft, GasSpent) :-
	prop(Unit, gas, GasCost),
	GasSpent is UnitsLeft*GasCost.

% Calculate the resource spent; lower the number, more efficient the
% unit is.
resourceSpent(Unit, GasToMin, UnitsLeft, ResourceSpent) :-
	prop(Unit,mineral, MinCost),
	prop(Unit,gas,GasCost),
	UnitCost = MinCost+GasCost*GasToMin,
	ResourceSpent is UnitsLeft*UnitCost.

% Calculate the resource spent, returning the Mineral and Gas spent
% separate.
resourceSpent2(Unit, GasToMin, UnitsLeft, MineralSpent, GasSpent, ResourceSpent) :-
	prop(Unit, mineral, MinCost),
	prop(Unit,gas,GasCost),
	UnitCost = MinCost+GasCost*GasToMin,
	MineralSpent is UnitsLeft*MinCost,
	GasSpent is UnitsLeft*GasCost,
	ResourceSpent is UnitsLeft*UnitCost.

% Return the cost efficiency of the unit.
costEfficiency(Unit, GasToMin, UnitsLeft, MinAv, GasAv, (Unit,MinLeft,GasLeft,ResourceLeft,UnitsLeft)) :-
	prop(Unit, mineral, MinCost),
	prop(Unit,gas,GasCost),
	UnitCost = MinCost+GasCost*GasToMin,
	ResourceAv = MinAv+GasAv*GasToMin,
	MineralSpent is UnitsLeft*MinCost,
	GasSpent is UnitsLeft*GasCost,
	ResourceSpent is UnitsLeft*UnitCost,
	buildUnits(Unit,MinAv,GasAv,N),
	MinLeft is MinAv-(N*MinCost-MineralSpent),
	GasLeft is GasAv-(N*GasCost-GasSpent),
	ResourceLeft is ResourceAv-((N*MinCost+N*GasCost*GasToMin)-ResourceSpent).

% Return the list of all units' cost efficiency
costEfficiencyList([],_,_,_,[]).
costEfficiencyList([(Unit,UnitsLeft)|T],MinAv,GasAv,GasToMin,[R1|R]) :-
	costEfficiency(Unit, GasToMin, UnitsLeft, MinAv, GasAv, R1),
	costEfficiencyList(T,MinAv,GasAv,GasToMin,R).


% find the most cost efficient unit; Not working properly atm...
max([],X,X,_).
max([(Unit,UnitsLeft)|T],(M,MLeft),X,GasToMin,MinAv,GasAv) :-
costEfficiency(Unit, GasToMin, UnitsLeft, MinAv, GasAv, (Unit,MinLeft,GasLeft,Unit1Cost,UnitsLeft)),
costEfficiency(M, GasToMin, MLeft, MinAv, GasAv, (M,MinLeft,GasLeft,Unit2Cost,MLeft)),
Unit1Cost =< Unit2Cost -> max(T,Unit,X,GasToMin,MinAv,GasAv);max(T,M,X,GasToMin,MinAv,GasAv).

costEfficientUnit([H|T],Unit,GasToMin,MinAv,GasAv) :- max(T,H,Unit,GasToMin,MinAv,GasAv).

